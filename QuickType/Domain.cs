// <auto-generated />
//
// To parse this JSON data, add NuGet 'Newtonsoft.Json' then do:
//
//    using QuickType;
//
//    var domain = Domain.FromJson(jsonString);

namespace QuickType
{
    using System;
    using System.Collections.Generic;

    using System.Globalization;
    using Newtonsoft.Json;
    using Newtonsoft.Json.Converters;
    using J = Newtonsoft.Json.JsonPropertyAttribute;
    using R = Newtonsoft.Json.Required;
    using N = Newtonsoft.Json.NullValueHandling;

    public partial class DomainJson
    {
        [J("name")] public string Name { get; set; }
        [J("region")] public Region Region { get; set; }
        [J("domainentrance", NullValueHandling = N.Ignore)] public string Domainentrance { get; set; }
        [J("domaintype")] public Domaintype Domaintype { get; set; }
        [J("description")] public string Description { get; set; }
        [J("recommendedlevel")] public long Recommendedlevel { get; set; }
        [J("recommendedelements")] public Recommendedelement[] Recommendedelements { get; set; }
        [J("unlockrank")] public long Unlockrank { get; set; }
        [J("rewardpreview")] public Rewardpreview[] Rewardpreview { get; set; }
        [J("disorder")] public string[] Disorder { get; set; }
        [J("monsterlist")] public string[] Monsterlist { get; set; }
        [J("images")] public Images Images { get; set; }
        [J("version")] public Version Version { get; set; }
        [J("daysofweek", NullValueHandling = N.Ignore)] public Daysofweek[] Daysofweek { get; set; }
    }

    public partial class Images
    {
        [J("namepic")] public string Namepic { get; set; }
    }

    public partial class Rewardpreview
    {
        [J("name")] public string Name { get; set; }
        [J("count", NullValueHandling = N.Ignore)] public long? Count { get; set; }
        [J("rarity", NullValueHandling = N.Ignore)][JsonConverter(typeof(ParseStringConverter))] public long? Rarity { get; set; }
    }

    public enum Daysofweek { 周一, 周三, 周二, 周五, 周六, 周四, 周日 };

    public enum Domaintype { 圣遗物, 天赋培养素材, 武器突破素材 };

    public enum Recommendedelement { 冰元素, 岩元素, 水元素, 火元素, 草元素, 雷元素, 风元素 };

    public enum Region { 璃月, 稻妻, 蒙德, 须弥 };

    public enum Version { Empty, The26, The30, The33 };

    public partial class DomainJson
    {
        public static DomainJson[] FromJson(string json) => JsonConvert.DeserializeObject<DomainJson[]>(json, QuickType.Converter.Settings);
    }

    public static class Serialize
    {
        public static string ToJson(this DomainJson[] self) => JsonConvert.SerializeObject(self, QuickType.Converter.Settings);
    }

    internal static class Converter
    {
        public static readonly JsonSerializerSettings Settings = new JsonSerializerSettings
        {
            MetadataPropertyHandling = MetadataPropertyHandling.Ignore,
            DateParseHandling = DateParseHandling.None,
            Converters =
            {
                DaysofweekConverter.Singleton,
                DomaintypeConverter.Singleton,
                RecommendedelementConverter.Singleton,
                RegionConverter.Singleton,
                VersionConverter.Singleton,
                new IsoDateTimeConverter { DateTimeStyles = DateTimeStyles.AssumeUniversal }
            },
        };
    }

    internal class DaysofweekConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(Daysofweek) || t == typeof(Daysofweek?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            if (reader.TokenType == JsonToken.Null) return null;
            var value = serializer.Deserialize<string>(reader);
            switch (value)
            {
                case "周一":
                    return Daysofweek.周一;
                case "周三":
                    return Daysofweek.周三;
                case "周二":
                    return Daysofweek.周二;
                case "周五":
                    return Daysofweek.周五;
                case "周六":
                    return Daysofweek.周六;
                case "周四":
                    return Daysofweek.周四;
                case "周日":
                    return Daysofweek.周日;
            }
            throw new Exception("Cannot unmarshal type Daysofweek");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            if (untypedValue == null)
            {
                serializer.Serialize(writer, null);
                return;
            }
            var value = (Daysofweek)untypedValue;
            switch (value)
            {
                case Daysofweek.周一:
                    serializer.Serialize(writer, "周一");
                    return;
                case Daysofweek.周三:
                    serializer.Serialize(writer, "周三");
                    return;
                case Daysofweek.周二:
                    serializer.Serialize(writer, "周二");
                    return;
                case Daysofweek.周五:
                    serializer.Serialize(writer, "周五");
                    return;
                case Daysofweek.周六:
                    serializer.Serialize(writer, "周六");
                    return;
                case Daysofweek.周四:
                    serializer.Serialize(writer, "周四");
                    return;
                case Daysofweek.周日:
                    serializer.Serialize(writer, "周日");
                    return;
            }
            throw new Exception("Cannot marshal type Daysofweek");
        }

        public static readonly DaysofweekConverter Singleton = new DaysofweekConverter();
    }

    internal class DomaintypeConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(Domaintype) || t == typeof(Domaintype?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            if (reader.TokenType == JsonToken.Null) return null;
            var value = serializer.Deserialize<string>(reader);
            switch (value)
            {
                case "圣遗物":
                    return Domaintype.圣遗物;
                case "天赋培养素材":
                    return Domaintype.天赋培养素材;
                case "武器突破素材":
                    return Domaintype.武器突破素材;
            }
            throw new Exception("Cannot unmarshal type Domaintype");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            if (untypedValue == null)
            {
                serializer.Serialize(writer, null);
                return;
            }
            var value = (Domaintype)untypedValue;
            switch (value)
            {
                case Domaintype.圣遗物:
                    serializer.Serialize(writer, "圣遗物");
                    return;
                case Domaintype.天赋培养素材:
                    serializer.Serialize(writer, "天赋培养素材");
                    return;
                case Domaintype.武器突破素材:
                    serializer.Serialize(writer, "武器突破素材");
                    return;
            }
            throw new Exception("Cannot marshal type Domaintype");
        }

        public static readonly DomaintypeConverter Singleton = new DomaintypeConverter();
    }

    internal class RecommendedelementConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(Recommendedelement) || t == typeof(Recommendedelement?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            if (reader.TokenType == JsonToken.Null) return null;
            var value = serializer.Deserialize<string>(reader);
            switch (value)
            {
                case "冰元素":
                    return Recommendedelement.冰元素;
                case "岩元素":
                    return Recommendedelement.岩元素;
                case "水元素":
                    return Recommendedelement.水元素;
                case "火元素":
                    return Recommendedelement.火元素;
                case "草元素":
                    return Recommendedelement.草元素;
                case "雷元素":
                    return Recommendedelement.雷元素;
                case "风元素":
                    return Recommendedelement.风元素;
            }
            throw new Exception("Cannot unmarshal type Recommendedelement");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            if (untypedValue == null)
            {
                serializer.Serialize(writer, null);
                return;
            }
            var value = (Recommendedelement)untypedValue;
            switch (value)
            {
                case Recommendedelement.冰元素:
                    serializer.Serialize(writer, "冰元素");
                    return;
                case Recommendedelement.岩元素:
                    serializer.Serialize(writer, "岩元素");
                    return;
                case Recommendedelement.水元素:
                    serializer.Serialize(writer, "水元素");
                    return;
                case Recommendedelement.火元素:
                    serializer.Serialize(writer, "火元素");
                    return;
                case Recommendedelement.草元素:
                    serializer.Serialize(writer, "草元素");
                    return;
                case Recommendedelement.雷元素:
                    serializer.Serialize(writer, "雷元素");
                    return;
                case Recommendedelement.风元素:
                    serializer.Serialize(writer, "风元素");
                    return;
            }
            throw new Exception("Cannot marshal type Recommendedelement");
        }

        public static readonly RecommendedelementConverter Singleton = new RecommendedelementConverter();
    }

    internal class RegionConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(Region) || t == typeof(Region?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            if (reader.TokenType == JsonToken.Null) return null;
            var value = serializer.Deserialize<string>(reader);
            switch (value)
            {
                case "璃月":
                    return Region.璃月;
                case "稻妻":
                    return Region.稻妻;
                case "蒙德":
                    return Region.蒙德;
                case "须弥":
                    return Region.须弥;
            }
            throw new Exception("Cannot unmarshal type Region");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            if (untypedValue == null)
            {
                serializer.Serialize(writer, null);
                return;
            }
            var value = (Region)untypedValue;
            switch (value)
            {
                case Region.璃月:
                    serializer.Serialize(writer, "璃月");
                    return;
                case Region.稻妻:
                    serializer.Serialize(writer, "稻妻");
                    return;
                case Region.蒙德:
                    serializer.Serialize(writer, "蒙德");
                    return;
                case Region.须弥:
                    serializer.Serialize(writer, "须弥");
                    return;
            }
            throw new Exception("Cannot marshal type Region");
        }

        public static readonly RegionConverter Singleton = new RegionConverter();
    }

    internal class ParseStringConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(long) || t == typeof(long?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            if (reader.TokenType == JsonToken.Null) return null;
            var value = serializer.Deserialize<string>(reader);
            long l;
            if (Int64.TryParse(value, out l))
            {
                return l;
            }
            throw new Exception("Cannot unmarshal type long");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            if (untypedValue == null)
            {
                serializer.Serialize(writer, null);
                return;
            }
            var value = (long)untypedValue;
            serializer.Serialize(writer, value.ToString());
            return;
        }

        public static readonly ParseStringConverter Singleton = new ParseStringConverter();
    }

    internal class VersionConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(Version) || t == typeof(Version?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            if (reader.TokenType == JsonToken.Null) return null;
            var value = serializer.Deserialize<string>(reader);
            switch (value)
            {
                case "":
                    return Version.Empty;
                case "2.6":
                    return Version.The26;
                case "3.0":
                    return Version.The30;
                case "3.3":
                    return Version.The33;
            }
            throw new Exception("Cannot unmarshal type Version");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            if (untypedValue == null)
            {
                serializer.Serialize(writer, null);
                return;
            }
            var value = (Version)untypedValue;
            switch (value)
            {
                case Version.Empty:
                    serializer.Serialize(writer, "");
                    return;
                case Version.The26:
                    serializer.Serialize(writer, "2.6");
                    return;
                case Version.The30:
                    serializer.Serialize(writer, "3.0");
                    return;
                case Version.The33:
                    serializer.Serialize(writer, "3.3");
                    return;
            }
            throw new Exception("Cannot marshal type Version");
        }

        public static readonly VersionConverter Singleton = new VersionConverter();
    }
}
